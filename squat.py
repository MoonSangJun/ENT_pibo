# import cv2
# import mediapipe as mp
# import numpy as np
# from datetime import datetime
# from firebase_config import db
# from tts_stt import speak  # ‚úÖ TTS Ï∂îÍ∞Ä

# # MediaPipe Ï¥àÍ∏∞Ìôî
# mp_drawing = mp.solutions.drawing_utils
# mp_pose = mp.solutions.pose

# # Í∞ÅÎèÑ Í≥ÑÏÇ∞ Ìï®Ïàò
# def calculate_angle(a, b, c):
#     a = np.array(a)
#     b = np.array(b)
#     c = np.array(c)

#     radians = np.arctan2(c[1]-b[1], c[0]-b[0]) - np.arctan2(a[1]-b[1], a[0]-b[0])
#     angle = np.abs(radians * 180.0 / np.pi)
#     if angle > 180.0:
#         angle = 360 - angle
#     return angle

# # Ï†ïÌôïÎèÑ Ï†êÏàò Í≥ÑÏÇ∞ (Í∞êÏ†ê ÏôÑÌôî)
# def calculate_accuracy_score(squat_angle):
#     ideal_angle = 90
#     error = abs(squat_angle - ideal_angle)
#     score = max(0, 100 - error * 0.3)
#     return int(score)

# # FirebaseÏóê Ï†êÏàò Ï†ÄÏû•
# def update_workout_score(user_id, workout_type, score, date=None):
#     if date is None:
#         date = datetime.now().strftime("%Y-%m-%d")

#     doc_ref = db.collection("users").document(user_id).collection(workout_type).document(date)
#     doc = doc_ref.get()
#     if doc.exists:
#         prev_data = doc.to_dict()
#         prev_score = prev_data.get("score", 0)
#         prev_sets = prev_data.get("sets", 0)
#     else:
#         prev_score = 0
#         prev_sets = 0

#     new_score = prev_score + score
#     new_sets = prev_sets + 1

#     doc_ref.set({
#         "score": new_score,
#         "sets": new_sets
#     })

#     total_ref = db.collection("users").document(user_id).collection("total").document(date)
#     total_doc = total_ref.get()
#     if total_doc.exists:
#         prev_total = total_doc.to_dict().get("score", 0)
#     else:
#         prev_total = 0

#     total_ref.set({
#         "score": prev_total + score
#     })

#     exp_ref = db.collection("users").document(user_id).collection("total").document("exp")
#     exp_doc = exp_ref.get()
#     if exp_doc.exists:
#         prev_exp = exp_doc.to_dict().get("score", 0)
#         exp_ref.update({"score": prev_exp + score})
#     else:
#         exp_ref.set({"score": score})

#     update_user_exp_and_level(user_id, score)

# def calculate_level(exp):
#     level = 1
#     threshold = 1000
#     while exp >= threshold:
#         level += 1
#         threshold *= 2
#     return level

# def update_user_exp_and_level(user_id, added_score):
#     user_ref = db.collection("users").document(user_id)
#     user_doc = user_ref.get()

#     if user_doc.exists():
#         prev_data = user_doc.to_dict()
#         current_exp = prev_data.get("exp", 0)
#     else:
#         current_exp = 0

#     new_exp = current_exp + added_score
#     new_level = calculate_level(new_exp)

#     user_ref.set({
#         "exp": new_exp,
#         "level": new_level
#     }, merge=True)

# def run_squat(user_id):
#     cap = cv2.VideoCapture(0)
#     counter = 0
#     stage = None
#     score_list = []
#     last_feedback = None  # ‚úÖ ÎßàÏßÄÎßâ ÌîºÎìúÎ∞± Ï†ÄÏû•Ïö©

#     with mp_pose.Pose(min_detection_confidence=0.5, min_tracking_confidence=0.5) as pose:
#         while cap.isOpened():
#             ret, frame = cap.read()
#             if not ret:
#                 break

#             image = cv2.cvtColor(frame, cv2.COLOR_BGR2RGB)
#             image.flags.writeable = False
#             results = pose.process(image)
#             image.flags.writeable = True
#             image = cv2.cvtColor(image, cv2.COLOR_RGB2BGR)

#             try:
#                 if not results.pose_landmarks:
#                     continue

#                 landmarks = results.pose_landmarks.landmark
#                 required_points = [
#                     mp_pose.PoseLandmark.LEFT_HIP.value,
#                     mp_pose.PoseLandmark.LEFT_KNEE.value,
#                     mp_pose.PoseLandmark.LEFT_ANKLE.value
#                 ]

#                 if not all(landmarks[i].visibility > 0.5 for i in required_points):
#                     continue

#                 hip = [landmarks[mp_pose.PoseLandmark.LEFT_HIP.value].x,
#                        landmarks[mp_pose.PoseLandmark.LEFT_HIP.value].y]
#                 knee = [landmarks[mp_pose.PoseLandmark.LEFT_KNEE.value].x,
#                         landmarks[mp_pose.PoseLandmark.LEFT_KNEE.value].y]
#                 ankle = [landmarks[mp_pose.PoseLandmark.LEFT_ANKLE.value].x,
#                          landmarks[mp_pose.PoseLandmark.LEFT_ANKLE.value].y]

#                 squat_angle = calculate_angle(hip, knee, ankle)
#                 accuracy = calculate_accuracy_score(squat_angle)

#                 cv2.putText(image, f'SQUAT ANGLE: {int(squat_angle)}', (10, 30),
#                             cv2.FONT_HERSHEY_SIMPLEX, 0.7, (0, 255, 255), 2)
#                 cv2.putText(image, f'ACCURACY: {accuracy}', (10, 60),
#                             cv2.FONT_HERSHEY_SIMPLEX, 0.7, (255, 255, 255), 2)

#                 if squat_angle < 100 and stage != "down":
#                     stage = "down"

#                 elif squat_angle > 150 and stage == "down":
#                     stage = "up"
#                     counter += 1
#                     score_list.append(accuracy)
#                     print(f"‚úÖ {counter}Ìöå ÏôÑÎ£å (Ï†ïÌôïÎèÑ: {accuracy})")
#                     print(f"{squat_angle}")

#                     # ‚úÖ 1ÌöåÎãπ ÏûêÏÑ∏ ÌîºÎìúÎ∞± (Ï§ëÎ≥µ Î∞©ÏßÄ Ìè¨Ìï®)
#                     if squat_angle <= 60:
#                         feedback = "Ï°∞Í∏àÎßå Îçú ÏïâÏïÑÎèÑ Í¥úÏ∞ÆÏïÑÏöî."
#                     elif squat_angle >= 120:
#                         feedback = "Ï°∞Í∏à Îçî ÏïâÏïÑÏ£ºÏÑ∏Ïöî."
#                     else:
#                         feedback = "Ï¢ãÏùÄ ÏûêÏÑ∏ÏòàÏöî!"

#                     if feedback != last_feedback:
#                         speak(feedback)
#                         last_feedback = feedback

#                     if counter % 12 == 0:
#                         set_score = int(sum(score_list) / len(score_list))
#                         print(f"üèÅ ÏÑ∏Ìä∏ ÏôÑÎ£å! ÌèâÍ∑† Ï†êÏàò: {set_score}")
#                         speak(f"ÏÑ∏Ìä∏ ÏôÑÎ£å! ÌèâÍ∑† Ï†êÏàòÎäî {set_score}Ï†êÏûÖÎãàÎã§.")
#                         update_workout_score(user_id, "squat", set_score)
#                         update_workout_score(user_id, "total", set_score)
#                         score_list = []

#             except Exception:
#                 pass

#             mp_drawing.draw_landmarks(image, results.pose_landmarks, mp_pose.POSE_CONNECTIONS)
#             cv2.imshow("Squat Assistant", image)
#             if cv2.waitKey(10) & 0xFF == ord('q'):
#                 break

#     cap.release()
#     cv2.destroyAllWindows()

import cv2
import mediapipe as mp
import numpy as np
from datetime import datetime
from firebase_config import db
from tts_stt_mac import speak  # ‚úÖ TTS (gTTS Îì± ÏÇ¨Ïö©)

# MediaPipe Ï¥àÍ∏∞Ìôî
mp_drawing = mp.solutions.drawing_utils
mp_pose = mp.solutions.pose

# ‚úÖ 3D Í∞ÅÎèÑ Í≥ÑÏÇ∞ Ìï®Ïàò
def calculate_3d_angle(a, b, c):
    ba = np.array(a) - np.array(b)
    bc = np.array(c) - np.array(b)
    cosine_angle = np.dot(ba, bc) / (np.linalg.norm(ba) * np.linalg.norm(bc))
    angle = np.arccos(np.clip(cosine_angle, -1.0, 1.0))
    return np.degrees(angle)


# Ï†ïÌôïÎèÑ Ï†êÏàò Í≥ÑÏÇ∞
def calculate_accuracy_score(squat_angle):
    ideal_angle = 90
    error = abs(squat_angle - ideal_angle)
    return int(max(0, 100 - error * 0.3))

# FirebaseÏóê Ï†êÏàò Ï†ÄÏû•
def update_workout_score(user_id, workout_type, score, date=None):
    if date is None:
        date = datetime.now().strftime("%Y-%m-%d")

    # Ïö¥ÎèôÎ≥Ñ Í∏∞Î°ù
    doc_ref = db.collection("users").document(user_id).collection(workout_type).document(date)
    doc = doc_ref.get()
    prev_score = doc.to_dict().get("score", 0) if doc.exists else 0
    prev_sets = doc.to_dict().get("sets", 0) if doc.exists else 0

    doc_ref.set({
        "score": prev_score + score,
        "sets": prev_sets + 1
    })

    # ÎÇ†ÏßúÎ≥Ñ Ï†ÑÏ≤¥ Ï†ÄÏû•
    total_ref = db.collection("users").document(user_id).collection("total").document(date)
    total_doc = total_ref.get()
    prev_total = total_doc.to_dict().get("score", 0) if total_doc.exists else 0
    total_ref.set({"score": prev_total + score})

    # ÎàÑÏ†Å Í≤ΩÌóòÏπò Ï†ÄÏû•
    exp_ref = db.collection("users").document(user_id).collection("total").document("exp")
    exp_doc = exp_ref.get()
    prev_exp = exp_doc.to_dict().get("score", 0) if exp_doc.exists else 0
    exp_ref.set({"score": prev_exp + score})

    # Î†àÎ≤® ÏóÖÎç∞Ïù¥Ìä∏
    update_user_exp_and_level(user_id, score)

def calculate_level(exp):
    level = 1
    threshold = 1000
    while exp >= threshold:
        level += 1
        threshold *= 2
    return level

def update_user_exp_and_level(user_id, added_score):
    user_ref = db.collection("users").document(user_id)
    user_doc = user_ref.get()
    current_exp = user_doc.to_dict().get("exp", 0) if user_doc.exists else 0
    new_exp = current_exp + added_score
    new_level = calculate_level(new_exp)

    user_ref.set({
        "exp": new_exp,
        "level": new_level
    }, merge=True)

# ‚úÖ Î©îÏù∏ Ïä§ÏøºÌä∏ Ìï®Ïàò
def run_squat(user_id):
    cap = cv2.VideoCapture(0)
    counter = 0
    stage = None
    score_list = []
    last_feedback = None
    min_squat_angle = None

    with mp_pose.Pose(min_detection_confidence=0.5, min_tracking_confidence=0.5) as pose:
        while cap.isOpened():
            ret, frame = cap.read()
            if not ret:
                break

            image = cv2.cvtColor(frame, cv2.COLOR_BGR2RGB)
            image.flags.writeable = False
            results = pose.process(image)
            image.flags.writeable = True
            image = cv2.cvtColor(image, cv2.COLOR_RGB2BGR)

            try:
                if not results.pose_landmarks:
                    continue

                landmarks = results.pose_landmarks.landmark
                required_points = [mp_pose.PoseLandmark.LEFT_HIP.value,
                                   mp_pose.PoseLandmark.LEFT_KNEE.value,
                                   mp_pose.PoseLandmark.LEFT_ANKLE.value]
                if not all(landmarks[i].visibility > 0.5 for i in required_points):
                    continue

                # Ï¢åÌëú Ï∂îÏ∂ú (3D)
                hip = [landmarks[mp_pose.PoseLandmark.LEFT_HIP.value].x,
                       landmarks[mp_pose.PoseLandmark.LEFT_HIP.value].y,
                       landmarks[mp_pose.PoseLandmark.LEFT_HIP.value].z]
                knee = [landmarks[mp_pose.PoseLandmark.LEFT_KNEE.value].x,
                        landmarks[mp_pose.PoseLandmark.LEFT_KNEE.value].y,
                        landmarks[mp_pose.PoseLandmark.LEFT_KNEE.value].z]
                ankle = [landmarks[mp_pose.PoseLandmark.LEFT_ANKLE.value].x,
                         landmarks[mp_pose.PoseLandmark.LEFT_ANKLE.value].y,
                         landmarks[mp_pose.PoseLandmark.LEFT_ANKLE.value].z]

                squat_angle = calculate_3d_angle(hip, knee, ankle)

                # down ÏßÑÏûÖ
                if squat_angle < 120:
                    if stage != "down":
                        stage = "down"
                        min_squat_angle = squat_angle
                    else:
                        min_squat_angle = min(min_squat_angle, squat_angle)

                # up Ï†ÑÌôò
                elif squat_angle > 170 and stage == "down":
                    stage = "up"
                    counter += 1
                    score = calculate_accuracy_score(min_squat_angle)
                    score_list.append(score)
                    print(f"‚úÖ {counter}Ìöå ÏôÑÎ£å (ÏµúÏÜå ÏïµÍ∏Ä: {min_squat_angle:.1f}, Ï†ïÌôïÎèÑ: {score})")

                    # ÌîºÎìúÎ∞±
                    if min_squat_angle <= 75:
                        feedback = "Ï°∞Í∏àÎßå Îçú ÏïâÏïÑÎèÑ Í¥úÏ∞ÆÏïÑÏöî."
                    elif min_squat_angle >= 90:
                        feedback = "Ï°∞Í∏à Îçî ÏïâÏïÑÏ£ºÏÑ∏Ïöî."
                    else:
                        feedback = "Ï¢ãÏùÄ ÏûêÏÑ∏ÏòàÏöî!"

                    if feedback != last_feedback:
                        speak(feedback)
                        last_feedback = feedback

                    min_squat_angle = None  # Ï¥àÍ∏∞Ìôî

                    # ‚úÖ ÏÑ∏Ìä∏ÎßàÎã§ Ï†ÄÏû•
                    if counter % 12 == 0:
                        set_score = int(sum(score_list) / len(score_list))
                        print(f"üèÅ ÏÑ∏Ìä∏ ÏôÑÎ£å! ÌèâÍ∑† Ï†êÏàò: {set_score}")
                        speak(f"ÏÑ∏Ìä∏ ÏôÑÎ£å! ÌèâÍ∑† Ï†êÏàòÎäî {set_score}Ï†êÏûÖÎãàÎã§.")
                        update_workout_score(user_id, "squat", set_score)
                        score_list = []
                        counter = 0

                # ÌôîÎ©¥Ïóê ÌÖçÏä§Ìä∏ ÌëúÏãú
                cv2.putText(image, f'SQUAT ANGLE: {int(squat_angle)}', (10, 30),
                            cv2.FONT_HERSHEY_SIMPLEX, 0.7, (0, 255, 255), 2)

            except Exception:
                pass

            mp_drawing.draw_landmarks(image, results.pose_landmarks, mp_pose.POSE_CONNECTIONS)
            cv2.imshow("Squat Assistant", image)
            if cv2.waitKey(10) & 0xFF == ord('q'):
                break

    cap.release()
    cv2.destroyAllWindows()
